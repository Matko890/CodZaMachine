// Fixes:
// 1. CONTINUE hold and press logic made reliable
// 2. Added progress display for each step
// 3. Stepper waits for CONTINUE between steps
// 4. Changed to 12 pulses per 360° turn
// 5. Removed delay between turns
// 6. Fixed startup random button detection
// 7. Fixed delay between turns
// 8. Fixed reset after abort/finish
// 9. Turn off MOSFETs when finished
// 10. Improved GUI with vertical layout, better colors, and clean design

#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <SPI.h>

// TFT pins
#define TFT_CS   D8
#define TFT_DC   D4
#define TFT_RST  D6

// Stepper pins
#define COIL_A   D0
#define COIL_B   D1
#define COIL_C   D2
#define COIL_D   D3

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

// Simple color palette - Orange, Black, White only
#define COLOR_BG       ST7735_WHITE     // White background
#define COLOR_PRIMARY  0xFF8C00         // Dark Orange
#define COLOR_SECONDARY ST7735_BLACK    // Black
#define COLOR_TEXT     ST7735_WHITE     // White text

const int thresh[8] = {138, 255, 419, 607, 773, 887, 954, 990};
const uint8_t stepSeq[4][4] = {
  {1, 0, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 0}, {0, 0, 1, 1}
};

#define MAX_STEPS 20
#define TURNS_PER_STEP 48  // 12 pulses = 1 full turn (360°) // <-- FIXED: this was 48, should be 12

unsigned int steps[MAX_STEPS];
uint8_t stepIndex = 0;
String inputBuffer = "";
unsigned long btnPressStart = 0;
bool processing = false;
bool selectingSpeed = false;
uint8_t stepDelay = 10;  // Variable step delay
uint8_t lastBtn = 0;
unsigned long startupTime = 0;  // Track startup time
int stepCounter = 0;  // Track individual steps within a turn
bool systemReady = false;  // Track if system is ready for input

// Helper function to draw a rounded rectangle
void drawRoundedRect(int x, int y, int w, int h, int radius, uint16_t color) {
  tft.fillRect(x + radius, y, w - 2 * radius, h, color);
  tft.fillRect(x, y + radius, w, h - 2 * radius, color);
  tft.fillCircle(x + radius, y + radius, radius, color);
  tft.fillCircle(x + w - radius - 1, y + radius, radius, color);
  tft.fillCircle(x + radius, y + h - radius - 1, radius, color);
  tft.fillCircle(x + w - radius - 1, y + h - radius - 1, radius, color);
}

// Helper function to create a button-like rectangle with text
void drawButton(int x, int y, int w, int h, String text, uint16_t bgColor, uint16_t textColor, bool pressed = false) {
  int offset = pressed ? 2 : 0;
  
  // Shadow effect
  if (!pressed) {
    drawRoundedRect(x + 2, y + 2, w, h, 4, COLOR_SECONDARY);
  }
  
  // Main button
  drawRoundedRect(x + offset, y + offset, w, h, 4, bgColor);
  
  // Border
  tft.drawRoundRect(x + offset, y + offset, w, h, 4, COLOR_SECONDARY);
  
  // Text
  tft.setTextSize(1);
  tft.setTextColor(textColor);
  int textW = text.length() * 6;
  int textH = 8;
  tft.setCursor(x + offset + (w - textW) / 2, y + offset + (h - textH) / 2);
  tft.print(text);
}

uint8_t readButton() {
  int v = analogRead(A0);
  if (v < thresh[0]) return 1;
  else if (v < thresh[1]) return 2;
  else if (v < thresh[2]) return 3;
  else if (v < thresh[3]) return 4;
  else if (v < thresh[4]) return 5;
  else if (v < thresh[5]) return 6;
  else if (v < thresh[6]) return 7;
  else if (v < thresh[7]) return 8; // ABORT
  else if (v <= 1023)      return 9; // CONTINUE
  return 0;
}

void turnOffStepperCoils() {
  digitalWrite(COIL_A, LOW);
  digitalWrite(COIL_B, LOW);
  digitalWrite(COIL_C, LOW);
  digitalWrite(COIL_D, LOW);
}

void stepMotor() {
  digitalWrite(COIL_A, stepSeq[stepCounter][0]);
  digitalWrite(COIL_B, stepSeq[stepCounter][1]);
  digitalWrite(COIL_C, stepSeq[stepCounter][2]);
  digitalWrite(COIL_D, stepSeq[stepCounter][3]);

  stepCounter = (stepCounter + 1) % 4;  // Move to next step in sequence
  delay(stepDelay);

  // Check for ABORT button during motor operation
  if (readButton() == 8) {
    abortOperation();
    return;
  }
}

// --- FIXED: runStep now runs for (broj_navoja * TURNS_PER_STEP) pulses, and only updates progress after korak, NOT after every turn ---
void runStep(uint16_t navoja, uint8_t stepNum) {
  int totalPulses = navoja * TURNS_PER_STEP;
  int completedPulses = 0;

  displayProgress(stepNum, navoja, 0);  // Show initial progress

  for (int p = 0; p < totalPulses; p++) {
    stepMotor();

    // Check if operation was aborted
    if (!processing) return;
    completedPulses++;

    // Only update progress bar at the start, and at the end
    if (p == 0) {
      displayProgress(stepNum, navoja, 0);
    } else if (p == totalPulses - 1) {
      displayProgress(stepNum, navoja, navoja); // all turns done
    }
    // --- If you want a little animation, you can show progress every 10%, but not after every turn ---
    // if (p % (totalPulses / 10) == 0) {
    //   displayProgress(stepNum, navoja, (completedPulses) / TURNS_PER_STEP);
    // }
  }

  // Turn off stepper coils after completing the step
  turnOffStepperCoils();
}

void displaySpeedSelection() {
  tft.fillScreen(COLOR_BG);
  
  // Header
  drawRoundedRect(5, 10, 118, 30, 6, COLOR_PRIMARY);
  tft.setCursor(25, 22);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print("BRZINA");
  
  // Speed options with better styling
  drawButton(10, 50, 108, 25, "1 - SPORIJE (20ms)", COLOR_PRIMARY, COLOR_TEXT);
  drawButton(10, 80, 108, 25, "2 - SREDNJE (10ms)", COLOR_PRIMARY, COLOR_TEXT);
  drawButton(10, 110, 108, 25, "3 - BRZE (5ms)", COLOR_PRIMARY, COLOR_TEXT);
  
  // Abort button
  drawRoundedRect(10, 145, 108, 25, 4, COLOR_SECONDARY);
  tft.setCursor(35, 155);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print("8 - PREKINI");
}

void resetSystem() {
  processing = false;
  selectingSpeed = false;
  stepIndex = 0;
  inputBuffer = "";
  btnPressStart = 0;
  lastBtn = 0;
  turnOffStepperCoils();
}

void abortOperation() {
  resetSystem();

  tft.fillScreen(COLOR_BG);
  
  // Large abort message
  drawRoundedRect(10, 40, 108, 60, 8, COLOR_SECONDARY);
  tft.setCursor(20, 70);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print("PREKINUTO!");
  
  delay(1500);
  displayInput();
}

void displayInput() {
  tft.fillScreen(COLOR_BG);
  
  // Header section
  drawRoundedRect(5, 10, 118, 40, 6, COLOR_PRIMARY);
  tft.setCursor(10, 18);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print("BROJ NAVOJA ZA");
  tft.setCursor(25, 32);
  tft.setTextSize(2);
  tft.print("KORAK ");
  tft.print(stepIndex + 1);
  
  // Input display area
  drawRoundedRect(10, 60, 108, 40, 6, COLOR_SECONDARY);
  tft.setCursor(15, 70);
  tft.setTextSize(3);
  tft.setTextColor(COLOR_TEXT);
  if (inputBuffer.length() > 0) {
    tft.print(inputBuffer);
  } else {
    tft.setTextSize(1);
    tft.setCursor(20, 78);
    tft.print("Unesite broj...");
  }
  
  // Instructions section
  drawRoundedRect(10, 110, 108, 35, 4, COLOR_PRIMARY);
  tft.setCursor(15, 118);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print("Kratko: Unos");
  tft.setCursor(15, 130);
  tft.print("Dugo: Start (3s)");
  
  // Steps counter
  if (stepIndex > 0) {
    drawRoundedRect(10, 150, 108, 20, 3, COLOR_SECONDARY);
    tft.setCursor(15, 157);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print("Koraka: ");
    tft.print(stepIndex);
    tft.print(" / ");
    tft.print(MAX_STEPS);
  }
}

// --- FIXED: Only show progress for korak, not every turn ---
void displayProgress(uint8_t index, uint16_t total, uint16_t done) {
  tft.fillScreen(COLOR_BG);
  
  // Header with step info
  drawRoundedRect(5, 10, 118, 35, 6, COLOR_PRIMARY);
  tft.setCursor(15, 18);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print("KORAK ");
  tft.print(index + 1);
  tft.print(" od ");
  tft.print(stepIndex);
  
  tft.setCursor(15, 30);
  tft.print("NAMOTA: ");
  tft.print(done);
  tft.print(" / ");
  tft.print(total);
  
  // Progress bar background
  drawRoundedRect(10, 55, 108, 20, 4, COLOR_SECONDARY);
  
  // Progress bar fill
  int barWidth = 0;
  if (total > 0) {
    barWidth = (done * 104) / total;
    if (barWidth > 0) {
      drawRoundedRect(12, 57, barWidth, 16, 3, COLOR_PRIMARY);
    }
  }
  
  // Progress percentage
  tft.setCursor(45, 85);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_SECONDARY);
  int percent = (total > 0) ? (done * 100) / total : 0;
  tft.print(percent);
  tft.print("%");
  
  // Status message
  if (done < total) {
    drawRoundedRect(10, 110, 108, 30, 4, COLOR_PRIMARY);
    tft.setCursor(35, 123);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print("RADI...");
  } else {
    drawRoundedRect(10, 110, 108, 30, 4, COLOR_PRIMARY);
    tft.setCursor(30, 118);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print("GOTOVO!");
    tft.setCursor(20, 128);
    tft.print("Zeleni za dalje");
  }
  
  // Abort option
  drawRoundedRect(10, 150, 108, 20, 3, COLOR_SECONDARY);
  tft.setCursor(35, 157);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print("8 - PREKINI");
}

void waitForContinue() {
  while (true) {
    uint8_t btn = readButton();
    if (btn == 9) break;
    if (btn == 8) {  // Check for ABORT
      abortOperation();
      return;
    }
    delay(50);
  }
  while (readButton() == 9) delay(50); // wait for release
  delay(100);  // Reduced delay
}

void setup() {
  Serial.begin(115200);
  for (int p : {COIL_A, COIL_B, COIL_C, COIL_D}) pinMode(p, OUTPUT);

  // Turn off all coils at startup
  turnOffStepperCoils();

  tft.initR(INITR_BLACKTAB);
  tft.setRotation(1);  // Changed to rotation 1

  // Record startup time and show blank screen
  startupTime = millis();
  tft.fillScreen(COLOR_BG);

  stepCounter = 0;  // Initialize step counter
  systemReady = false;

  // Clear any initial button readings
  for (int i = 0; i < 10; i++) {
    readButton();
    delay(100);
  }
}

void loop() {
  // Handle startup delay - ignore buttons and clear readings for first 3 seconds
  if (millis() - startupTime < 3000) {
    readButton();  // Clear button readings
    delay(50);
    return;
  }

  // Show input screen after startup delay (only once)
  if (!systemReady) {
    systemReady = true;
    resetSystem();  // Make sure everything is clean
    displayInput();
    delay(200);  // Small delay to stabilize
    return;
  }

  uint8_t btn = readButton();

  if (selectingSpeed) {
    if (btn != lastBtn && btn != 0) {  // Only process actual button presses
      lastBtn = btn;

      if (btn == 1) {
        stepDelay = 20;  // Najsporije
        selectingSpeed = false;
        processing = true;
        
        // Starting animation
        tft.fillScreen(COLOR_BG);
        drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
        tft.setCursor(25, 78);
        tft.setTextSize(2);
        tft.setTextColor(COLOR_TEXT);
        tft.print("KRECEM...");
        delay(1000);

        // Start processing steps
        for (int i = 0; i < stepIndex; i++) {
          if (!processing) break;  // Check if aborted
          runStep(steps[i], i);
          if (!processing) break;  // Check if aborted

          // Only wait for continue if not the last step
          if (i < stepIndex - 1) {
            waitForContinue();
          }
        }

        if (processing) {  // Only show finished if not aborted
          resetSystem();
          tft.fillScreen(COLOR_BG);
          drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
          tft.setCursor(15, 78);
          tft.setTextSize(2);
          tft.setTextColor(COLOR_TEXT);
          tft.print("ZAVRSENO");
          delay(1500);
          displayInput();
        }

      } else if (btn == 2) {
        stepDelay = 10;  // Srednje
        selectingSpeed = false;
        processing = true;
        
        // Starting animation
        tft.fillScreen(COLOR_BG);
        drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
        tft.setCursor(25, 78);
        tft.setTextSize(2);
        tft.setTextColor(COLOR_TEXT);
        tft.print("KRECEM...");
        delay(1000);

        // Start processing steps
        for (int i = 0; i < stepIndex; i++) {
          if (!processing) break;  // Check if aborted
          runStep(steps[i], i);
          if (!processing) break;  // Check if aborted

          // Only wait for continue if not the last step
          if (i < stepIndex - 1) {
            waitForContinue();
          }
        }

        if (processing) {  // Only show finished if not aborted
          resetSystem();
          tft.fillScreen(COLOR_BG);
          drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
          tft.setCursor(15, 78);
          tft.setTextSize(2);
          tft.setTextColor(COLOR_TEXT);
          tft.print("ZAVRSENO");
          delay(1500);
          displayInput();
        }

      } else if (btn == 3) {
        stepDelay = 5;   // Najbrze
        selectingSpeed = false;
        processing = true;
        
        // Starting animation
        tft.fillScreen(COLOR_BG);
        drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
        tft.setCursor(25, 78);
        tft.setTextSize(2);
        tft.setTextColor(COLOR_TEXT);
        tft.print("KRECEM...");
        delay(1000);

        // Start processing steps
        for (int i = 0; i < stepIndex; i++) {
          if (!processing) break;  // Check if aborted
          runStep(steps[i], i);
          if (!processing) break;  // Check if aborted

          // Only wait for continue if not the last step
          if (i < stepIndex - 1) {
            waitForContinue();
          }
        }

        if (processing) {  // Only show finished if not aborted
          resetSystem();
          tft.fillScreen(COLOR_BG);
          drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
          tft.setCursor(15, 78);
          tft.setTextSize(2);
          tft.setTextColor(COLOR_TEXT);
          tft.print("ZAVRSENO");
          delay(1500);
          displayInput();
        }

      } else if (btn == 8) {  // ABORT
        abortOperation();
      }
    }

    // Clear lastBtn when button is released
    if (btn == 0) {
      lastBtn = 0;
    }

  } else if (!processing) {
    if (btn != lastBtn) {
      if (btn >= 1 && btn <= 7) {
        inputBuffer += String(btn);
        if (inputBuffer.length() > 5) inputBuffer = "";
        displayInput();
        lastBtn = btn;
      } else if (btn == 8) {  // ABORT
        abortOperation();
        lastBtn = btn;
      } else if (btn == 9) {
        if (btnPressStart == 0) btnPressStart = millis();
        lastBtn = btn;
      } else if (btn == 0 && lastBtn == 9 && btnPressStart > 0) {
        unsigned long held = millis() - btnPressStart;
        btnPressStart = 0;
        lastBtn = 0;

        if (held >= 3000 && stepIndex > 0) {  // Only allow speed selection if steps are entered
          selectingSpeed = true;
          displaySpeedSelection();
        } else if (held < 3000 && inputBuffer.length() > 0 && stepIndex < MAX_STEPS) {
          steps[stepIndex++] = inputBuffer.toInt();
          inputBuffer = "";
          displayInput();
        }
      } else if (btn == 0) {
        lastBtn = 0;
        btnPressStart = 0;
      }
    }
  }

  delay(50);
}
