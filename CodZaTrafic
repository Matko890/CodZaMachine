// Enhanced Transformer Winding Controller - FIXED FOR GPIO 3 (RX PIN) 
// - Using GPIO 3 (RX pin) with Serial disabled
// - Fixed speed control copied from working version
// - Smooth transitions and animations
// - Language toggle (Croatian/English - Hold button 5 for 3 seconds)
// - Step confirmation screen
// - Blocking stepper with responsive UI (FIXED FROM WORKING VERSION)
// - Animated progress bar

#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <SPI.h>

// TFT pins
#define TFT_CS   D8
#define TFT_DC   D4

// Stepper pins - Using GPIO 3 (RX pin) with Serial disabled
#define COIL_A   D0
#define COIL_B   D1
#define COIL_C   3    // GPIO 3 (RX pin) - Serial must be disabled
#define COIL_D   D3

// Hardware abort button
#define ABORT_BTN D6

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, -1);

// Simple color palette - Orange, Black, White, Green
#define COLOR_BG       ST7735_WHITE     // White background
#define COLOR_PRIMARY  ST7735_ORANGE    // Orange
#define COLOR_SECONDARY ST7735_BLACK    // Black
#define COLOR_TEXT     ST7735_WHITE     // White text
#define COLOR_GREEN    ST7735_GREEN     // Green for continue
#define COLOR_RED      ST7735_RED       // Red for abort
#define COLOR_GRAY     0x8410           // Gray

// Updated threshold values for 9 buttons + continue (10 total values on A0)
const int thresh[10] = {150, 240, 300, 400, 500, 600, 700, 800, 900, 950};

const uint8_t stepSeq[4][4] = {
  {1, 0, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 0}, {0, 0, 1, 1}
};

#define MAX_STEPS 20
#define TURNS_PER_STEP 48  // 48 pulses = 1 full turn (360Â°)

// Language system
bool isEnglish = false;  // Start with Croatian
unsigned long button5PressStart = 0;
bool button5Held = false;

// Animation and UI state
unsigned long lastCursorBlink = 0;
bool cursorVisible = true;
uint8_t highlightedButton = 0;
unsigned long highlightTime = 0;

// System state
unsigned int steps[MAX_STEPS];
uint8_t stepIndex = 0;
String inputBuffer = "";
unsigned long btnPressStart = 0;
bool processing = false;
bool selectingSpeed = false;
bool massManufacturing = false;
bool showingConfirmation = false;
uint16_t transformerCount = 0;
uint8_t stepDelay = 10;  // Speed delay in milliseconds
uint8_t lastBtn = 0;
int stepCounter = 0;
bool lastAbortState = LOW;

// Language strings
struct LanguageStrings {
  const char* windingCount;
  const char* step;
  const char* of;
  const char* turns;
  const char* enterNumber;
  const char* shortPress;
  const char* longPress;
  const char* steps;
  const char* speed;
  const char* slower;
  const char* medium;
  const char* faster;
  const char* working;
  const char* complete;
  const char* greenContinue;
  const char* aborted;
  const char* finished;
  const char* transformer;
  const char* newTransformer;
  const char* abort;
  const char* starting;
  const char* confirm;
  const char* confirmSteps;
  const char* edit;
  const char* start;
};

const LanguageStrings croatian = {
  "BROJ NAVOJA ZA", "KORAK", "od", "NAMOTA", "Unesite broj...",
  "Kratko: Unos", "Dugo: Start (1.5s)", "Koraka", "BRZINA",
  "SPORIJE (20ms)", "SREDNJE (10ms)", "BRZE (5ms)", "RADI...",
  "GOTOVO!", "Zeleni za dalje", "PREKINUTO!", "ZAVRSENO",
  "Transformator", "Novi transformator:", "PREKINI", "KRECEM...",
  "POTVRDA", "Potvrdi korake:", "4-Uredi", "Start"
};

const LanguageStrings english = {
  "TURNS COUNT FOR", "STEP", "of", "TURNS", "Enter number...",
  "Short: Input", "Long: Start (1.5s)", "Steps", "SPEED",
  "SLOWER (20ms)", "MEDIUM (10ms)", "FASTER (5ms)", "WORKING...",
  "DONE!", "Green to continue", "ABORTED!", "FINISHED",
  "Transformer", "New transformer:", "ABORT", "STARTING...",
  "CONFIRM", "Confirm steps:", "4-Edit", "Start"
};

const LanguageStrings* lang = &croatian;

// Helper function to draw a rounded rectangle
void drawRoundedRect(int x, int y, int w, int h, int radius, uint16_t color) {
  tft.fillRect(x + radius, y, w - 2 * radius, h, color);
  tft.fillRect(x, y + radius, w, h - 2 * radius, color);
  tft.fillCircle(x + radius, y + radius, radius, color);
  tft.fillCircle(x + w - radius - 1, y + radius, radius, color);
  tft.fillCircle(x + radius, y + h - radius - 1, radius, color);
  tft.fillCircle(x + w - radius - 1, y + h - radius - 1, radius, color);
}

void drawButtonWithHighlight(int x, int y, int w, int h, String text, uint16_t bgColor, uint16_t textColor, bool highlighted = false, bool pressed = false) {
  int offset = pressed ? 2 : 0;
  uint16_t finalBgColor = highlighted ? COLOR_SECONDARY : bgColor;
  uint16_t finalTextColor = highlighted ? COLOR_PRIMARY : textColor;
  
  // Glow effect for highlighted buttons
  if (highlighted) {
    drawRoundedRect(x - 2, y - 2, w + 4, h + 4, 6, COLOR_GRAY);
  }
  
  // Shadow effect
  if (!pressed) {
    drawRoundedRect(x + 2, y + 2, w, h, 4, COLOR_SECONDARY);
  }
  
  // Main button
  drawRoundedRect(x + offset, y + offset, w, h, 4, finalBgColor);
  
  // Border
  tft.drawRoundRect(x + offset, y + offset, w, h, 4, COLOR_SECONDARY);
  
  // Text
  tft.setTextSize(1);
  tft.setTextColor(finalTextColor);
  int textW = text.length() * 6;
  int textH = 8;
  tft.setCursor(x + offset + (w - textW) / 2, y + offset + (h - textH) / 2);
  tft.print(text);
}

uint8_t readButton() {
  int v = analogRead(A0);
  if (v < thresh[0]) return 1;
  else if (v < thresh[1]) return 2;
  else if (v < thresh[2]) return 3;
  else if (v < thresh[3]) return 4;
  else if (v < thresh[4]) return 5;
  else if (v < thresh[5]) return 6;
  else if (v < thresh[6]) return 7;
  else if (v < thresh[7]) return 8;
  else if (v < thresh[8]) return 9;
  else if (v < thresh[9]) return 10; // CONTINUE (Green button)
  return 0;
}

bool checkAbortButton() {
  static unsigned long lastCheck = 0;
  if (millis() - lastCheck < 50) return false;
  lastCheck = millis();
  
  bool currentState = digitalRead(ABORT_BTN);
  if (currentState == HIGH && lastAbortState == LOW) {
    lastAbortState = currentState;
    return true;
  }
  lastAbortState = currentState;
  return false;
}

void fadeTransition() {
  // Simple fade effect by drawing overlay rectangles
  for (int i = 0; i < 8; i++) {
    tft.drawRect(i, i, 128 - 2*i, 160 - 2*i, COLOR_GRAY);
    delay(20);
  }
}

void abortOperation() {
  fadeTransition();
  resetSystem();
  
  tft.fillScreen(COLOR_BG);
  drawRoundedRect(10, 60, 108, 40, 8, COLOR_RED);
  tft.setCursor(30, 75);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->aborted);
  
  delay(2000);
  fadeTransition();
  displayInput();
}

void turnOffStepperCoils() {
  digitalWrite(COIL_A, LOW);
  digitalWrite(COIL_B, LOW);
  digitalWrite(COIL_C, LOW);
  digitalWrite(COIL_D, LOW);
}

// FIXED: Use blocking stepper motor control like working version
void stepMotor() {
  digitalWrite(COIL_A, stepSeq[stepCounter][0]);
  digitalWrite(COIL_B, stepSeq[stepCounter][1]);
  digitalWrite(COIL_C, stepSeq[stepCounter][2]);
  digitalWrite(COIL_D, stepSeq[stepCounter][3]);

  stepCounter = (stepCounter + 1) % 4;
  delay(stepDelay);  // Use the selected speed delay

  // Check abort button during stepping - this stops the stepper immediately
  if (checkAbortButton()) {
    processing = false;
    turnOffStepperCoils();  // Turn off coils immediately when aborted
  }
}

// FIXED: Use working version's runStep function
void runStep(uint16_t navoja, uint8_t stepNum) {
  int totalPulses = navoja * TURNS_PER_STEP;
  int completedPulses = 0;

  displayProgress(stepNum, navoja, 0);

  for (int p = 0; p < totalPulses; p++) {
    stepMotor();

    // Check if processing was stopped (by abort button in stepMotor)
    if (!processing) {
      turnOffStepperCoils();
      return;
    }
    
    completedPulses++;

    // Update display only at start and end to reduce flicker
    if (p == 0) {
      displayProgress(stepNum, navoja, 0);
    } else if (p == totalPulses - 1) {
      displayProgress(stepNum, navoja, navoja);
    }
  }

  turnOffStepperCoils();
}

void displaySpeedSelection() {
  fadeTransition();
  tft.fillScreen(COLOR_BG);
  
  // Header
  drawRoundedRect(5, 10, 118, 35, 6, COLOR_PRIMARY);
  tft.setCursor(35, 20);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->speed);
  
  // Speed options with highlighting
  drawButtonWithHighlight(10, 55, 108, 25, String("1 - ") + lang->slower, COLOR_PRIMARY, COLOR_TEXT, highlightedButton == 1);
  drawButtonWithHighlight(10, 85, 108, 25, String("2 - ") + lang->medium, COLOR_PRIMARY, COLOR_TEXT, highlightedButton == 2);
  drawButtonWithHighlight(10, 115, 108, 25, String("3 - ") + lang->faster, COLOR_PRIMARY, COLOR_TEXT, highlightedButton == 3);
}

void displayConfirmation() {
  fadeTransition();
  tft.fillScreen(COLOR_BG);
  
  // Header
  drawRoundedRect(5, 5, 118, 30, 6, COLOR_PRIMARY);
  tft.setCursor(35, 15);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->confirm);
  
  // Steps list
  tft.setCursor(10, 45);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_SECONDARY);
  tft.print(lang->confirmSteps);
  
  int y = 60;
  for (int i = 0; i < stepIndex && i < 8; i++) {
    tft.setCursor(15, y);
    tft.setTextColor(COLOR_SECONDARY);
    tft.print(lang->step);
    tft.print(" ");
    tft.print(i + 1);
    tft.print(": ");
    tft.setTextColor(COLOR_PRIMARY);
    tft.print(steps[i]);
    tft.setTextColor(COLOR_SECONDARY);
    tft.print(" ");
    tft.print(lang->turns);
    y += 12;
  }
  
  // Instructions
  drawRoundedRect(5, 140, 58, 20, 3, COLOR_PRIMARY);
  tft.setCursor(8, 147);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->edit);
  
  drawRoundedRect(65, 140, 58, 20, 3, COLOR_GREEN);
  tft.setCursor(80, 147);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->start);
}

void resetSystem() {
  processing = false;
  selectingSpeed = false;
  showingConfirmation = false;
  stepIndex = 0;
  inputBuffer = "";
  btnPressStart = 0;
  lastBtn = 0;
  massManufacturing = false;
  turnOffStepperCoils();
  lastAbortState = LOW;
  highlightedButton = 0;
  button5PressStart = 0;
  button5Held = false;
}

void displayInput() {
  tft.fillScreen(COLOR_BG);
  
  // Language indicator
  tft.setCursor(100, 5);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_SECONDARY);
  tft.print(isEnglish ? "EN" : "HR");
  
  // Header section
  drawRoundedRect(5, 15, 118, 40, 6, COLOR_PRIMARY);
  tft.setCursor(8, 25);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->windingCount);
  tft.setCursor(25, 40);
  tft.setTextSize(2);
  tft.print(lang->step);
  tft.print(" ");
  tft.print(stepIndex + 1);
  
  // Input display area with blinking cursor
  drawRoundedRect(10, 65, 108, 40, 6, COLOR_SECONDARY);
  tft.setCursor(15, 75);
  tft.setTextSize(3);
  tft.setTextColor(COLOR_TEXT);
  
  if (inputBuffer.length() > 0) {
    tft.print(inputBuffer);
    // Blinking cursor
    if (millis() - lastCursorBlink > 500) {
      cursorVisible = !cursorVisible;
      lastCursorBlink = millis();
    }
    if (cursorVisible) {
      tft.print("_");
    }
  } else {
    tft.setTextSize(1);
    tft.setCursor(20, 83);
    tft.print(lang->enterNumber);
  }
  
  // Instructions section
  drawRoundedRect(10, 115, 108, 35, 4, COLOR_PRIMARY);
  tft.setCursor(15, 125);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->shortPress);
  tft.setCursor(15, 137);
  tft.print(lang->longPress);
  
  // Steps counter with progress bar
  if (stepIndex > 0) {
    drawRoundedRect(10, 155, 108, 20, 3, COLOR_SECONDARY);
    tft.setCursor(15, 162);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print(lang->steps);
    tft.print(": ");
    tft.print(stepIndex);
    tft.print(" / ");
    tft.print(MAX_STEPS);
    
    // Mini progress bar
    int progressWidth = (stepIndex * 40) / MAX_STEPS;
    drawRoundedRect(65, 165, 40, 3, 1, COLOR_GRAY);
    if (progressWidth > 0) {
      drawRoundedRect(65, 165, progressWidth, 3, 1, COLOR_GREEN);
    }
  }
}

void displayTransformerComplete() {
  fadeTransition();
  tft.fillScreen(COLOR_BG);
  
  // Header with completion message
  drawRoundedRect(5, 20, 118, 40, 6, COLOR_GREEN);
  tft.setCursor(25, 35);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->finished);
  
  // Transformer counter
  drawRoundedRect(10, 70, 108, 30, 4, COLOR_PRIMARY);
  tft.setCursor(15, 80);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->transformer);
  tft.print(" #");
  tft.setTextSize(2);
  tft.print(transformerCount);
  
  // Instructions for next transformer
  drawRoundedRect(10, 110, 108, 45, 4, COLOR_PRIMARY);
  tft.setCursor(15, 120);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->newTransformer);
  tft.setCursor(15, 132);
  tft.print(lang->greenContinue);
  tft.setCursor(15, 144);
  tft.print("D6 - ");
  tft.print(lang->abort);
}

void displayProgress(uint8_t index, uint16_t total, uint16_t done) {
  tft.fillScreen(COLOR_BG);
  
  // Header with step info
  drawRoundedRect(5, 10, 118, 35, 6, COLOR_PRIMARY);
  tft.setCursor(15, 18);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->step);
  tft.print(" ");
  tft.print(index + 1);
  tft.print(" ");
  tft.print(lang->of);
  tft.print(" ");
  tft.print(stepIndex);
  
  tft.setCursor(15, 30);
  tft.print(lang->turns);
  tft.print(": ");
  tft.print(done);
  tft.print(" / ");
  tft.print(total);
  
  // Animated progress bar
  drawRoundedRect(10, 55, 108, 20, 4, COLOR_GRAY);
  
  int barWidth = 0;
  if (total > 0) {
    barWidth = (done * 104) / total;
    if (barWidth > 0) {
      // Gradient effect
      for (int i = 0; i < barWidth; i += 2) {
        uint16_t color = (i % 4 == 0) ? COLOR_GREEN : COLOR_PRIMARY;
        tft.drawLine(12 + i, 57, 12 + i, 73, color);
      }
    }
  }
  
  // Progress percentage
  tft.setCursor(45, 85);
  tft.setTextSize(3);
  tft.setTextColor(COLOR_SECONDARY);
  int percent = (total > 0) ? (done * 100) / total : 0;
  tft.print(percent);
  tft.print("%");
  
  // Status message
  if (done < total) {
    drawRoundedRect(10, 120, 108, 30, 4, COLOR_PRIMARY);
    tft.setCursor(35, 133);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print(lang->working);
  } else {
    drawRoundedRect(10, 120, 108, 30, 4, COLOR_GREEN);
    tft.setCursor(30, 128);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_TEXT);
    tft.print(lang->complete);
    tft.setCursor(20, 140);
    tft.print(lang->greenContinue);
  }
}

void waitForContinue() {
  while (true) {
    uint8_t btn = readButton();
    if (btn == 10) break;
    
    if (checkAbortButton()) {
      abortOperation();
      return;
    }
    
    updateAnimations();
    delay(50);
  }
  while (readButton() == 10) delay(50);
  delay(100);
}

void updateAnimations() {
  // Update cursor blinking
  if (millis() - lastCursorBlink > 500) {
    cursorVisible = !cursorVisible;
    lastCursorBlink = millis();
  }
  
  // Update button highlighting
  if (highlightedButton > 0 && millis() - highlightTime > 100) {
    highlightedButton = 0;
  }
}

// FIXED: Use working version's runManufacturingCycle function
void runManufacturingCycle() {
  processing = true;
  
  // Starting animation
  fadeTransition();
  tft.fillScreen(COLOR_BG);
  drawRoundedRect(10, 60, 108, 40, 8, COLOR_PRIMARY);
  tft.setCursor(20, 78);
  tft.setTextSize(2);
  tft.setTextColor(COLOR_TEXT);
  tft.print(lang->starting);
  delay(1000);

  // Start processing steps
  for (int i = 0; i < stepIndex; i++) {
    if (!processing) break;
    runStep(steps[i], i);
    if (!processing) break;

    if (i < stepIndex - 1) {
      waitForContinue();
    }
  }

  if (processing) {
    transformerCount++;
    processing = false;
    massManufacturing = true;
    displayTransformerComplete();
  }
}

void setup() {
  // DO NOT initialize Serial - it conflicts with GPIO 3 (RX pin)
  // Serial.begin(115200); // DISABLED to use GPIO 3
  
  // Initialize pins individually to avoid type conflicts
  pinMode(COIL_A, OUTPUT);
  pinMode(COIL_B, OUTPUT);
  pinMode(COIL_C, OUTPUT);  // GPIO 3 (RX pin)
  pinMode(COIL_D, OUTPUT);
  pinMode(ABORT_BTN, INPUT);
  
  // Turn off all coils at startup
  turnOffStepperCoils();

  // Initialize display
  tft.initR(INITR_BLACKTAB);
  tft.setRotation(4);
  tft.fillScreen(COLOR_BG);

  // Startup animation
  for (int i = 0; i < 64; i++) {
    tft.drawCircle(64, 80, i, COLOR_PRIMARY);
    delay(10);
  }

  // Initialize variables
  stepCounter = 0;
  lastAbortState = LOW;
  
  // Quick stabilization
  for (int i = 0; i < 5; i++) {
    readButton();
    delay(20);
  }
  
  lastAbortState = digitalRead(ABORT_BTN);
  
  resetSystem();
  fadeTransition();
  displayInput();
}

void loop() {
  // Check abort button
  if (checkAbortButton()) {
    abortOperation();
    return;
  }
  
  // Update animations
  updateAnimations();
  
  uint8_t btn = readButton();
  
  // Handle mass manufacturing mode
  if (massManufacturing) {
    if (btn != lastBtn && btn != 0) {
      lastBtn = btn;
      highlightedButton = btn;
      highlightTime = millis();
      
      if (btn == 10) {
        massManufacturing = false;
        runManufacturingCycle();
      }
    }
    
    if (btn == 0) lastBtn = 0;
    delay(50);
    return;
  }
  
  // Handle confirmation screen
  if (showingConfirmation) {
    if (btn != lastBtn && btn != 0) {
      lastBtn = btn;
      highlightedButton = btn;
      highlightTime = millis();
      
      if (btn == 4) {  // Edit
        showingConfirmation = false;
        fadeTransition();
        displayInput();
      } else if (btn == 10) {  // Start
        showingConfirmation = false;
        selectingSpeed = true;
        highlightedButton = 0;
        displaySpeedSelection();
      }
    }
    
    if (btn == 0) lastBtn = 0;
    delay(50);
    return;
  }
  
  // FIXED: Handle speed selection - copied from working version
  if (selectingSpeed) {
    if (btn != lastBtn && btn != 0) {
      lastBtn = btn;
      highlightedButton = btn;
      highlightTime = millis();

      if (btn == 1) {
        stepDelay = 20;  // Slower
        selectingSpeed = false;
        highlightedButton = 0;
        runManufacturingCycle();
      } else if (btn == 2) {
        stepDelay = 10;  // Medium  
        selectingSpeed = false;
        highlightedButton = 0;
        runManufacturingCycle();
      } else if (btn == 3) {
        stepDelay = 5;   // Faster
        selectingSpeed = false;
        highlightedButton = 0;
        runManufacturingCycle();
      }
    }

    if (btn == 0) {
      lastBtn = 0;
      // REMOVED: displaySpeedSelection() call that was causing constant refresh
    }
    
    delay(50);
    return;

  } else if (!processing) {
    // Handle button 5 - both number input and language toggle
    if (btn == 5 && lastBtn != 5) {
      button5PressStart = millis();
      button5Held = true;
      lastBtn = btn;
    } else if (btn == 5 && button5Held) {
      if (millis() - button5PressStart >= 3000) {
        // Change language after 3 seconds
        isEnglish = !isEnglish;
        lang = isEnglish ? &english : &croatian;
        button5Held = false;
        button5PressStart = 0;
        lastBtn = 0;
        
        // Update language indicator
        tft.fillRect(95, 0, 33, 15, COLOR_BG);
        tft.setCursor(100, 5);
        tft.setTextSize(1);
        tft.setTextColor(COLOR_SECONDARY);
        tft.print(isEnglish ? "EN" : "HR");
      }
    } else if (btn == 0 && lastBtn == 5 && button5Held) {
      if (millis() - button5PressStart < 3000) {
        // Released before 3 seconds - treat as number input
        inputBuffer += "5";
        if (inputBuffer.length() > 5) inputBuffer = "";
        highlightedButton = 5;
        highlightTime = millis();
        displayInput();
      }
      button5Held = false;
      button5PressStart = 0;
      lastBtn = 0;
    }
    
    // Handle input mode for other buttons (1-4, 6-9)
    if (btn != lastBtn && btn != 0) {
      if (btn >= 1 && btn <= 9 && btn != 5) {
        inputBuffer += String(btn);
        if (inputBuffer.length() > 5) inputBuffer = "";
        highlightedButton = btn;
        highlightTime = millis();
        displayInput();
        lastBtn = btn;
      } else if (btn == 10) {
        if (btnPressStart == 0) btnPressStart = millis();
        lastBtn = btn;
      }
    } else if (btn == 0 && lastBtn == 10 && btnPressStart > 0) {
      unsigned long held = millis() - btnPressStart;
      btnPressStart = 0;
      lastBtn = 0;
      
      if (held >= 1500 && stepIndex > 0) {
        showingConfirmation = true;
        displayConfirmation();
      } else if (held < 1500 && inputBuffer.length() > 0 && stepIndex < MAX_STEPS) {
        steps[stepIndex++] = inputBuffer.toInt();
        inputBuffer = "";
        displayInput();
      }
    } else if (btn == 0 && lastBtn != 5) {
      lastBtn = 0;
      btnPressStart = 0;
    }
  }
  
  delay(50);
}
